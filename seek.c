/*
modified from code generated by GPT https://chatgpt.com/share/35bfdeb0-151c-4111-bc8e-cfac26358a07 -- last prompt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
#include "constants.h"
#include "utils.h"

void print_path_with_color(const char* path, int is_dir, int is_exec) {
    if (is_dir) {
        printf(""BLU"%s"RESET"\n", path);
    } else {
        if(!is_exec) printf(""WHT"%s"RESET"\n", path);
        else printf(""GRN"%s"RESET"\n", path);
    }
}

void recursive_seek(const char* base_path, const char* target, int look_for_files, int look_for_dirs, char** found_path, int* found_count) {
    DIR *d;
    struct dirent *dir;
    struct stat file_stat;
    char path[MAX];

    d = opendir(base_path);
    if (!d) return;

    while ((dir = readdir(d)) != NULL) {
        //printf("+++++ READING the content %s +++++\n", dir->d_name);
        if (strcmp(dir->d_name, ".") == 0 || strcmp(dir->d_name, "..") == 0) {
            continue;
        }

        snprintf(path, MAX, "%s/%s", base_path, dir->d_name);
        //printf("%s\n", path);
        if (lstat(path, &file_stat) == -1) { // no symlinks
            continue;
        }

        // Ignore symbolic links
        if (S_ISLNK(file_stat.st_mode)) {
            continue;
        }
        
        //printf("dir->dname is %s and target is %s\n", path, target);
        if (S_ISDIR(file_stat.st_mode)) {
            
            if (look_for_dirs && strncmp(dir->d_name, target, strlen(target)-1) == 0) {
                (*found_count)++;
                *found_path = strdup(path);
                print_path_with_color(*found_path, 1, 1);
            }
            // Recurse into directory
            //printf(""MAG"into recursive"RESET"\n");
            recursive_seek(path, target, look_for_files, look_for_dirs, found_path, found_count);
            //printf(""MAG"outof recursive"RESET"\n");
        } else if (S_ISREG(file_stat.st_mode) && look_for_files && strncmp(dir->d_name, target, strlen(target)-1) == 0) {
            (*found_count)++;
            *found_path = strdup(path);
            print_path_with_color(*found_path, 0, file_stat.st_mode & S_IXUSR);
        }
        //printf(""CYN"readdir gives %s"RESET"\n", (dir = readdir(d)) == NULL?"NULL":"NOT NULL : MAY REPEAT ig");
    }
    closedir(d);
}

int seek(char** tokens, char* homedir) {
    int look_for_files = 1, look_for_dirs = 1, execute_flag = 0;
    char* target = NULL;
    char* directory = NULL;
    char* found_path = NULL;
    int found_count = 0;

    // Parse tokens to determine flags and arguments
    for (int i = 1; tokens[i] != NULL; i++) { // only diretories
        if(tokens[i][0] == '-'){
            if (strchr(tokens[i], 'd')) {
                look_for_files = 0;
            }
            if (strchr(tokens[i], 'f')) {
                look_for_dirs = 0;
            }
            if (strchr(tokens[i], 'e')) {
                execute_flag = 1;
            }
        }/* 
        else if (strcmp(tokens[i], "-d") == 0) {
            look_for_files = 0;
        } else if (strcmp(tokens[i], "-f") == 0) { // only files
            look_for_dirs = 0;
        } else if (strcmp(tokens[i], "-e") == 0) {
            execute_flag = 1;
        }  */
        else if (target == NULL) {
            target = tokens[i];
        } else if (directory == NULL) {
            directory = pre_process_path(tokens[i], homedir);
        }
    }

    if (target == NULL) {
        fprintf(stderr, "seek: missing target\n");
        return 1;
    }

    if (directory == NULL) {
        directory = ".";
    }

    // Perform the recursive search
    recursive_seek(directory, target, look_for_files, look_for_dirs, &found_path, &found_count);

    // Handle -e flag logic
    if (execute_flag && found_count == 1) {
        if (look_for_dirs && !look_for_files && access(found_path, X_OK) == 0) {
            chdir(found_path);
        } else if (look_for_files && !look_for_dirs && access(found_path, R_OK) == 0) {
            printf(""GRN"Only file found: %s"RESET"\n", found_path);
            FILE* fileptr = NULL;
            char ch = 0;
            fileptr = fopen(found_path, "r");
            if(fileptr == NULL){
                fprintf(stderr, ""RED"%s: cannot open file"RESET"", found_path);
            }
            //printf("%s\n",found_path);
            while ((ch = fgetc(fileptr))!=EOF){
                printf("%c", ch);
            }
            fclose(fileptr);
        }else{
            fprintf(stderr, ""RED"Missing permissions for task!"RESET"\n");
        }
    }

    free(found_path);
    return 0;
}
