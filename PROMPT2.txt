
// proclore.c

/*
Code initially generated by GPT : https://chatgpt.com/share/35bfdeb0-151c-4111-bc8e-cfac26358a07
prompt : proclore is used to obtain information regarding a process. If an argument is missing, print the information of your shell.
        Information required to print :
        pid ,Process Status (R/R+/S/S+/Z), Process group, Virtual Memory, Executable path of process
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "constants.h"
#define PID_LIMIT 10 // enough for 64 bit machines
int proclore(char** tokens) {
    char path[256];
    char buffer[1024];
    FILE *fp;
    int pid;
    if(tokens[1] == NULL){
        pid = getpid();
    }else {
        int ij = 0;
        for(ij=0;tokens[1][ij]!='\0';ij++){
            
            if(tokens[1][ij]<'0' || '9'<tokens[1][ij] || ij>PID_LIMIT){ // check if pid valid
                fprintf(stderr, ""RED"proclore: please enter valid pid\n"RESET"");
                return 1;
            }
        }
        pid = atoi(tokens[1]);
        
    }
    // Construct the path to the /proc/[pid]/status file
    snprintf(path, sizeof(path), "/proc/%d/status", pid);

    // Open the status file
    fp = fopen(path, "r");
    if (fp == NULL) {
        //perror(""RED"fopen"RESET"");
        fprintf(stderr, ""RED"proclore: No such process\n"RESET"");
        return 1;
    }

    // Initialize variables to store process information
    char process_status = '\0';
    int process_group = -1;
    unsigned long virtual_memory = 0;

    // Read the status file line by line
    while (fgets(buffer, sizeof(buffer), fp)) {
        if (strncmp(buffer, "State:", 6) == 0) {
            process_status = buffer[7];
        } else if (strncmp(buffer, "Tgid:", 5) == 0) {
            sscanf(buffer + 5, "%d", &process_group);
        } else if (strncmp(buffer, "VmSize:", 7) == 0) {
            sscanf(buffer + 7, "%lu", &virtual_memory);
        }
    }

    fclose(fp);

    // Construct the path to the /proc/[pid]/exe symbolic link
    snprintf(path, sizeof(path), "/proc/%d/exe", pid);
    ssize_t len = readlink(path, buffer, sizeof(buffer) - 1);
    if (len == -1) {
        perror(""RED"readlink"RESET"");
        return 1;
    }

    buffer[len] = '\0';  // Null-terminate the string

    // Print the process information
    printf("PID: %d\n", pid);
    printf("Process Status: %c\n", process_status);
    printf("Process Group ID: %d\n", process_group);
    printf("Virtual Memory (kB): %lu\n", virtual_memory);
    printf("Executable Path: %s\n", buffer);

    return 0;
}
/* 
int main(int argc, char *argv[]) {
    int pid;

    if (argc == 2) {
        pid = atoi(argv[1]);
    } else {
        pid = getpid();  // Get the current shell's PID if no argument is provided
    }

    proclore(pid);

    return 0;
}
 */

// pwd.c

#include <stdio.h>
#include <unistd.h>
#include "constants.h"
int pwd(){
    char cwdbuf[MAX];
    getcwd(cwdbuf, MAX);
    printf("%s", cwdbuf);
    return 0;
}
// reveal.c

/*
code generated by chatGPT https://chatgpt.com/c/41137d7e-a044-4581-960e-46ca8bb4409a
prompt : let us say I want to implement a command 'reveal' that lists content of present directory. How do I do that ?
further prompt : let's say i want to implement optional arguments of reveal such as -a to list dotfiles and -l to display file details too. How do I do that ? The current tokenize function does not support it

*/
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include "constants.h"
#include <time.h>
#include <grp.h>
#include <pwd.h>

#include "utils.h"
char* append_path_to_dirname(char* cwd, struct dirent *dir){
    char* path = (char*)malloc(MAX*sizeof(char));
    snprintf(path, MAX, "%s/%s", cwd, dir->d_name);
    return path;
}
// Function to implement the 'reveal' command
int reveal(char **tokens, char* homedir, char* prevdir){
    DIR *d;
    struct dirent *dir;
    struct stat file_stat;
    struct passwd *pw;
    struct group *gr;
    char* cwd = NULL;
    int show_all = 0;
    int show_long = 0;
    int i = 1;

    // Parse options
    while (tokens[i] != NULL){
        tokens[i] = pre_process_path(tokens[i], homedir);
        if(strcmp(tokens[i],"-")==0){
            //printf("reveal : prevdir is %s\n",prevdir);
            cwd = prevdir;
        }
        else if(tokens[i][0] == '-'){
            if (strchr(tokens[i], 'a')) {
                show_all = 1; // Show dotfiles
            }
            if (strchr(tokens[i], 'l')) {
                show_long = 1; // Show long format
            }
        }
        else{
            cwd = tokens[i];
            //printf("%s\n",cwd);
        }
        i++;
    }

    if(cwd == NULL){
        // Get the current working directory
        cwd = (char*)malloc(MAX*sizeof(char));
        if (getcwd(cwd, MAX) == NULL) {
            fprintf(stderr, ""RED"could not getcwd"RESET"\n");
            return 1;
        }
    }

    // Open the current directory
    //printf("directory to b opened is %s\n",cwd);
    d = opendir(cwd);
    if (d == NULL) {
        fprintf(stderr, ""RED"could not opendir"RESET"\n");
        return 1;
    }

    
/*     int fx = fork();
    if(fx>0) return 0;
    chdir(cwd);
 */
    /* 
    int n = scandir(cwd, &namelist, NULL, alphasort);
    if (n == -1) {
        perror("scandir");
        return 1;
    } 
    */
    // Read and print each entry in the directory
    while ((dir = readdir(d)) != NULL) {
        
        // Skip dotfiles if -a is not specified
        if (!show_all && dir->d_name[0] == '.') {
            continue;
        }

        // Print long format if -l is specified
        if (show_long) {
            //printf("before segma cwd/dir->d_name is %s/%s\n",cwd,dir->d_name);
            // edge case when dir->d_name is ..
            // causes segma

            char* path = (strcmp(dir->d_name, "..") != 0)? append_path_to_dirname(cwd, dir):".."; // handle edge case
            //printf("before segma path is %s\n",path); --debug line
            if (stat(path, &file_stat) == -1) {
                fprintf(stderr, ""RED"could not stat"RESET"\n");
                continue;
            }

            pw = getpwuid(file_stat.st_uid);
            gr = getgrgid(file_stat.st_gid);
            //printf("is reach ?\n"); --dubug line
            char *time_str = ctime(&file_stat.st_mtime);
            time_str[strlen(time_str) - 1] = '\0';
            printf("%c%c%c%c%c%c%c%c%c%c %ld %s %s %ld %s ",
                   (S_ISDIR(file_stat.st_mode)) ? 'd' : '-',
                   (file_stat.st_mode & S_IRUSR) ? 'r' : '-',
                   (file_stat.st_mode & S_IWUSR) ? 'w' : '-',
                   (file_stat.st_mode & S_IXUSR) ? 'x' : '-',
                   (file_stat.st_mode & S_IRGRP) ? 'r' : '-',
                   (file_stat.st_mode & S_IWGRP) ? 'w' : '-',
                   (file_stat.st_mode & S_IXGRP) ? 'x' : '-',
                   (file_stat.st_mode & S_IROTH) ? 'r' : '-',
                   (file_stat.st_mode & S_IWOTH) ? 'w' : '-',
                   (file_stat.st_mode & S_IXOTH) ? 'x' : '-',
                   file_stat.st_nlink,
                   pw->pw_name,
                   gr==NULL?""RED"NULL"RESET"":gr->gr_name, // handle problamatic case
                   // give NULL if group not found (eg for 1000)
                   file_stat.st_size,
                   time_str
            );
            if(S_ISDIR(file_stat.st_mode)){
                printf(""BLU"%s"RESET"\n", dir->d_name);
            }
            else if(file_stat.st_mode & S_IXUSR){
                printf(""GRN"%s"RESET"\n", dir->d_name);
            }
            else{
                printf("%s\n", dir->d_name);
            }
            
        } else {
            //char* path = append_path_to_dirname(cwd, dir);
            char* path = (strcmp(dir->d_name, "..") != 0)? append_path_to_dirname(cwd, dir):".."; // handle edge case
            if (stat(path, &file_stat) == -1) {
                fprintf(stderr, ""RED"reveal : could not stat"RESET"\n");
                continue;
            }
            if(S_ISDIR(file_stat.st_mode)){
                printf(""BLU"%s"RESET"\n", dir->d_name);
            }
            else if(file_stat.st_mode & S_IXUSR){
                printf(""GRN"%s"RESET"\n", dir->d_name);
            }
            else{
                printf("%s\n", dir->d_name);
            }
        }
    }

    // Close the directory
    closedir(d);
    return 0;
}

// seek.c

/*
modified from code generated by GPT https://chatgpt.com/share/35bfdeb0-151c-4111-bc8e-cfac26358a07 -- last prompt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
#include "constants.h"
#include "utils.h"

void print_path_with_color(const char* path, int is_dir, int is_exec) {
    if (is_dir) {
        printf(""BLU"%s"RESET"\n", path);
    } else {
        if(!is_exec) printf(""WHT"%s"RESET"\n", path);
        else printf(""GRN"%s"RESET"\n", path);
    }
}

void recursive_seek(const char* base_path, const char* target, int look_for_files, int look_for_dirs, char** found_path, int* found_count) {
    DIR *d;
    struct dirent *dir;
    struct stat file_stat;
    char path[MAX];

    d = opendir(base_path);
    if (!d) return;

    while ((dir = readdir(d)) != NULL) {
        //printf("+++++ READING the content %s +++++\n", dir->d_name);
        if (strcmp(dir->d_name, ".") == 0 || strcmp(dir->d_name, "..") == 0) {
            continue;
        }

        snprintf(path, MAX, "%s/%s", base_path, dir->d_name);
        //printf("%s\n", path);
        if (lstat(path, &file_stat) == -1) { // no symlinks
            continue;
        }

        // Ignore symbolic links
        if (S_ISLNK(file_stat.st_mode)) {
            continue;
        }
        
        //printf("dir->dname is %s and target is %s\n", path, target);
        if (S_ISDIR(file_stat.st_mode)) {
            
            if (look_for_dirs && strncmp(dir->d_name, target, strlen(target)-1) == 0) {
                (*found_count)++;
                *found_path = strdup(path);
                print_path_with_color(*found_path, 1, 1);
            }
            // Recurse into directory
            //printf(""MAG"into recursive"RESET"\n");
            recursive_seek(path, target, look_for_files, look_for_dirs, found_path, found_count);
            //printf(""MAG"outof recursive"RESET"\n");
        } else if (S_ISREG(file_stat.st_mode) && look_for_files && strncmp(dir->d_name, target, strlen(target)-1) == 0) {
            (*found_count)++;
            *found_path = strdup(path);
            print_path_with_color(*found_path, 0, file_stat.st_mode & S_IXUSR);
        }
        //printf(""CYN"readdir gives %s"RESET"\n", (dir = readdir(d)) == NULL?"NULL":"NOT NULL : MAY REPEAT ig");
    }
    closedir(d);
}

int seek(char** tokens, char* homedir) {
    int look_for_files = 1, look_for_dirs = 1, execute_flag = 0;
    char* target = NULL;
    char* directory = NULL;
    char* found_path = NULL;
    int found_count = 0;

    // Parse tokens to determine flags and arguments
    for (int i = 1; tokens[i] != NULL; i++) { // only diretories
        if(tokens[i][0] == '-'){
            if (strchr(tokens[i], 'd')) {
                look_for_files = 0;
            }
            if (strchr(tokens[i], 'f')) {
                look_for_dirs = 0;
            }
            if (strchr(tokens[i], 'e')) {
                execute_flag = 1;
            }
        }/* 
        else if (strcmp(tokens[i], "-d") == 0) {
            look_for_files = 0;
        } else if (strcmp(tokens[i], "-f") == 0) { // only files
            look_for_dirs = 0;
        } else if (strcmp(tokens[i], "-e") == 0) {
            execute_flag = 1;
        }  */
        else if (target == NULL) {
            target = tokens[i];
        } else if (directory == NULL) {
            directory = pre_process_path(tokens[i], homedir);
        }
    }

    if (target == NULL) {
        fprintf(stderr, "seek: missing target\n");
        return 1;
    }

    if (directory == NULL) {
        directory = ".";
    }

    // Perform the recursive search
    recursive_seek(directory, target, look_for_files, look_for_dirs, &found_path, &found_count);

    // Handle -e flag logic
    if (execute_flag && found_count == 1) {
        if (look_for_dirs && !look_for_files && access(found_path, X_OK) == 0) {
            chdir(found_path);
        } else if (look_for_files && !look_for_dirs && access(found_path, R_OK) == 0) {
            printf(""GRN"Only file found: %s"RESET"\n", found_path);
            FILE* fileptr = NULL;
            char ch = 0;
            fileptr = fopen(found_path, "r");
            if(fileptr == NULL){
                fprintf(stderr, ""RED"%s: cannot open file"RESET"", found_path);
            }
            //printf("%s\n",found_path);
            while ((ch = fgetc(fileptr))!=EOF){
                printf("%c", ch);
            }
            fclose(fileptr);
        }else{
            fprintf(stderr, ""RED"Missing permissions for task!"RESET"\n");
        }
    }

    free(found_path);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "constants.h"
#include "alias.h"
#include "input.h"
int main(){
    printf("hello\n");
    char* input = read_input();
    char** tokens = tokenise_input(input);
    //char** tokens = tokenise_input("alias reveall = reveal -l  -a  -la");
    char* str = (char*)malloc(MAX*sizeof(char));
    str[0]='\0';
    for(int i=3;tokens[i]!=NULL;i++){
        strcat(str, tokens[i]);
        strcat(str," ");
    }str[strlen(str)-1]=0;

    printf("%shello\nfff", str);

    return 0;
}
// utils.c

#include<stdlib.h>
#include<string.h>
#include<stdio.h>
#include "constants.h"
#include "input.h"
char* pre_process_path(char* path, char* homedir){ // convert ~ to homedir string
    if(path[0] == '~'){ 
        char* fullname = (char*)malloc((strlen(path)+strlen(homedir))*sizeof(char));
        strcpy(fullname, homedir);
        strcat(fullname, 1 + path);
        // printf("homedir is %s : %s\n",homedir,fullname);
        /* 
        if(chdir(fullname)<0){
            fprintf(stderr, ""RED"%s: No such directory"RESET"\n",fullname);
            return 1;
        }
        */
        return fullname;
    }
    return path;

}

char* stitchtokens(char** tokens){
    char* str = (char*)malloc(MAX*sizeof(char));
    str[0]='\0';
    for(int i=0;tokens[i]!=NULL;i++){
        strcat(str, tokens[i]);
        strcat(str," ");
    }str[strlen(str)-1]=0;
    return str;
}
void printtokens(char** tokens){

    printf("the tokens are: ");
    for(int i=0;tokens[i]!=NULL;i++){
        printf("'%s',", tokens[i]);
    }
    char* str = stitchtokens(tokens);
    printf("stitched command world be is: '%s'\n", str);
    //printf("stitched newtokens will be");
}#ifndef ALIAS_H
#define ALIAS_H
#include "constants.h"

typedef struct {
    char *alias;
    char *command;
} Alias;
// I can probaably use a better data structure such as a hashtable for O(1) accsess
// but this will do for now.
typedef struct {
    Alias* element;
    int alias_count;
} AliasList;

/* Alias aliases[MAX]; // can store MAX aliases
int alias_count = 0; */

int alias(char ** tokens, AliasList* aliases);
char** use_alias(char** tokens, char* command, AliasList* aliases, int aliasnum);
    

#endif//constants.h

#define MAX 4096
#define RED   "\x1B[31m"
#define GRN   "\x1B[32m"
#define YEL   "\x1B[33m"
#define BLU   "\x1B[34m"
#define MAG   "\x1B[35m"
#define CYN   "\x1B[36m"
#define WHT   "\x1B[37m"
#define RESET "\x1B[0m"
#define TOKEN_DELIMITERS " \t\r\a\n"
#define MAX_HISTORY 15
#define HISTORY_FILE "~/.myhistory"

// hop.h

int hop(char** tokens, char* homedir, char* prevdir);

//input.h

/*Modified code initially generated by GPT
https://chatgpt.com/share/35bfdeb0-151c-4111-bc8e-cfac26358a07 - first prompt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include "constants.h"
#include "hop.h"

//#ifdef Alias
#include "alias.h"




char *read_input();

char** tokenise_input(char* X);
int execute_command(char** tokens, char* homedir, char** prevdir, char* input, AliasList* aliases);
//#endif





// log.h
#include "alias.h"
void update_history(char* command, char* history_file);
void print_history(char* history_file);
void clear_history(char* history_file);
int is_log_command(const char* command);

int log_func(char** tokens, char* homedir, char** ptrprevdir, char* input, AliasList* aliases);
void execute_history_command(int index, char* homedir, char** ptrprevdir, char* input, char* history_file, AliasList* aliases);


// proclore.h

int proclore(char** tokens);
// pwd.h

int pwd();// reveal.h

int reveal(char **tokens, char* homedir, char* prevdir);// seek.h

void print_path_with_color(const char* path, int is_dir);
void recursive_seek(const char* base_path, const char* target, int look_for_files, int look_for_dirs, char** found_path, int* found_count);
int seek(char** tokens, char* homedir);// utils.h
char* stitchtokens(char** tokens);
char* pre_process_path(char* path, char* homedir);
void printtokens(char** tokens);