this is a shell that I implemented.
How do I make a shell config file .myshrc such that every command in it is run line by line everytime a shell session is began.
The myshrc file is a customized shell configuration file, similar to .bashrc, tailored to enhance your command-line experience. It includes useful aliases and functions to streamline your workflow and improve efficiency. In this you need to create your own .bashrc file which will use aliases and functions.
alias eg: alias reveall = reveal -la
function example: 
func mk_hop()
{
	mkdir "$1" # Create the directory
	hop "$1" # Change into the directory
}
another function example:
func hop_seek()
{
    hop "$1" # Hop into this directory
    seek "$1" # search for files/directories with the same name as the directory you just hopped into.
}




// main.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include "constants.h"
#include "hop.h"
#include "input.h"
#include "log.h"
#include "utils.h"
#include "alias.h"

int printprompt(char* homedirbuf){
    char cwdbuf[MAX];
    char loginbuf[MAX];
    char hostbuf[MAX];
    getcwd(cwdbuf, MAX);
    getlogin_r(loginbuf, MAX);
    gethostname(hostbuf, MAX);
    char* path;
    if(!strncmp(homedirbuf, cwdbuf, strlen(homedirbuf))){
        if(!strcmp(homedirbuf,cwdbuf)){
            path="~";
        }
        else{
            path = cwdbuf + (strlen(homedirbuf)-1);
            path[0]='~';
        }
    }
    else{
        path = cwdbuf;
    }
    printf("<"GRN"%s@%s"WHT":"BLU"%s"RESET"> ",loginbuf,hostbuf,path);


    return 0;
}

void shell_loop(AliasList* aliases) {
    char *input;
    char copybuf[MAX+1];
    char **args;
    char homedir[MAX];
    char* prevdir = "NULL";
    getcwd(homedir, MAX);
    char* history_file = pre_process_path(HISTORY_FILE, homedir);
    
    printf(""YEL"history file is at %s"RESET"\n", history_file);
    FILE* fptr = fopen("./.myhistory", "a");
    fclose(fptr);
    // strcpy(prevdir, homedir);
    do{
        printprompt(homedir);
        input = read_input();
        strcpy(copybuf, input);
        args = tokenise_input(input);
        if(args[0] != NULL){ // do nothing if empty input
            if(strcmp(args[0],"quit")==0) break; // command to quit shell
            update_history(copybuf, history_file);
            execute_command(args, homedir, &prevdir, copybuf, aliases); // run given command
        }
        //printf("%s\n",copybuf);
        free(input);
        free(args);
        
    }while(1);
}

int main(){
    AliasList* aliases = (AliasList*)malloc(1*sizeof(AliasList));
    aliases->element = (Alias*)malloc(MAX*sizeof(Alias));
    aliases->alias_count=0;
    shell_loop(aliases);
    return 0;
}



// alias.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "constants.h"
#include "alias.h"
#include "input.h"
#include "utils.h"
int alias(char ** tokens, AliasList* aliases){
    //int alias_count = aliases->alias_count;
    if(strcmp(tokens[0], "alias") !=0){
        fprintf(stderr, ""RED"not alias command"RESET"\n");
        return 1;
    }
    if (tokens[1] == NULL) {
        //printf("enter into printing\n");

        // List all aliases
        for (int i = 0; i < aliases->alias_count; i++) {
            printf("alias %s = '%s'\n", aliases->element[i].alias, aliases->element[i].command);
        }
        return 0;
    }
    if(strcmp(tokens[2],"=") != 0){
        fprintf(stderr, ""RED"alias: define using '='\n"RESET"");
        return 1;
    } 
    for (int i = 0; i < aliases->alias_count; i++) {
        if (strcmp(aliases->element[i].alias, tokens[1]) == 0) {
            
            free(aliases->element[i].command);
            char* str = (char*)malloc(MAX*sizeof(char));
            str[0]='\0';
            for(int i=3;tokens[i]!=NULL;i++){
                strcat(str, tokens[i]);
                strcat(str," ");
            }str[strlen(str)-1]=0;


            aliases->element[i].command = strdup(str);

            free(str);
            return 1;
        }
    }
    if(aliases->alias_count<MAX){
        char* str = (char*)malloc(MAX*sizeof(char));
        str[0]='\0';
        for(int i=3;tokens[i]!=NULL;i++){
            strcat(str, tokens[i]);
            strcat(str," ");
        }str[strlen(str)-1]=0;
        aliases->element[aliases->alias_count].alias = strdup(tokens[1]);
        aliases->element[aliases->alias_count].command = strdup(str);
        aliases->alias_count++;
        free(str);
    }else{
        fprintf(stderr, ""RED"alias: limit reached"RESET"");
        return 1;
    }
    return 0;
}

char** use_alias(char** tokens, char* command, AliasList* aliases, int aliasnum){
    //printtokens(tokens);
    char* aliascommand = strdup(aliases->element[aliasnum].command);
    tokens[0] = aliascommand;
    //printtokens(tokens);
    char* str = stitchtokens(tokens);
    char** newtokens = tokenise_input(str);
    return newtokens;
}




// hop.c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include <unistd.h>
#include "constants.h"
#include "utils.h"

int hop(char** tokens, char* homedir, char* prevdir){
    if(strcmp(tokens[0],"hop") != 0){
        fprintf(stderr, ""RED"not hop command"RESET"\n");
        return 1;
    }
    if(tokens[1] == NULL){
        chdir(homedir);
    }
    int i=1;
    while(tokens[i] != NULL){
        tokens[i]=pre_process_path(tokens[i], homedir);
        //printf("prevdir is %s\n",(prevdir==NULL)?"NULL":"NOT NULL");
        if(tokens[i][0] == '-'){
            if(strcmp(prevdir,"NULL")==0){
                fprintf(stderr, ""RED"previous directory undefined"RESET"\n");
                return 1;
            }
            chdir(prevdir);
        }
        else{
            // printf("%s\n",tokens[i]);
            if(chdir(tokens[i])<0){
                fprintf(stderr, ""RED"%s: No such directory"RESET"\n",tokens[i]);
                return 1;
            }
        }
        
        
        i++;
    }
    
    return 0;
}

//input.c


/*Modified code initially generated by GPT
https://chatgpt.com/share/35bfdeb0-151c-4111-bc8e-cfac26358a07 - first prompt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include "constants.h"
#include "hop.h"
#include "pwd.h"
#include "reveal.h"
#include "proclore.h"
#include "log.h"
#include "seek.h"
#include "alias.h"


char *read_input(){
    char *input = malloc(MAX * sizeof(char));
    if(!input){
        fprintf(stderr, "allocation error\n");
        exit(EXIT_FAILURE);
    }

    if(fgets(input, MAX, stdin) == NULL){
        if(feof(stdin)){
            exit(EXIT_SUCCESS);  // EOF, exit shell
        }
        else{
            perror("read_input");
            exit(EXIT_FAILURE);
        }
    }

    return input;
}

char** tokenise_input(char* X){
    char* token;
    char** tokens = (char**)malloc(MAX*sizeof(char*));
    token=strtok(X, TOKEN_DELIMITERS);
    int count=0;
    while(token != NULL){
        tokens[count] = token;

        count++;
        //printf("%dth loop\n",count++);
        //printf("%s\n",token);
        token=strtok(NULL, TOKEN_DELIMITERS);
    }
    tokens[count] = NULL;
    return tokens;
}

void handle_sigchld() {
    // Wait for all dead child processes
    while (waitpid(-1, NULL, WNOHANG) > 0) {}
}

int execute_command(char** tokens, char* homedir, char** ptrprevdir, char* input, AliasList* aliases){
    if(tokens[0]==NULL) return 0;
    for (int i = 0; i < aliases->alias_count; i++) { // check for aliases
        if (strcmp(aliases->element[i].alias, tokens[0]) == 0) {
            char** newtokens = use_alias(tokens, input, aliases, i);
            int errco = execute_command(newtokens, homedir, ptrprevdir, input, aliases);
            return errco;
        }
    }
    for(int i=0; tokens[i] != NULL; i++){
        if(strcmp(tokens[i], "&")==0){
            tokens[i]=NULL;
            struct sigaction sa;
            sa.sa_handler = &handle_sigchld;
            sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;
            sigemptyset(&sa.sa_mask);
            if (sigaction(SIGCHLD, &sa, NULL) == -1) {
                perror("sigaction");
                exit(EXIT_FAILURE);
            }
            int proc_id = fork();
            if(proc_id==0){
                int eid = execute_command(tokens, homedir, ptrprevdir, input, aliases);
                exit(eid);
            }
            printf(""MAG"Process running in background with PID: "RESET"%d\n", proc_id);
            execute_command(tokens+i+1, homedir, ptrprevdir, input, aliases);
            return 0;
        }
        if(strcmp(tokens[i], ";")==0){
            // replace first semicolon with NULL
            // and execute the tokens before it
            // and then recursively apply execute to the rest of the tokens
            tokens[i]=NULL; 
            execute_command(tokens, homedir, ptrprevdir, input, aliases); 
            execute_command(tokens+i+1, homedir, ptrprevdir, input, aliases);
            return 0;
        }
    }
    if(strcmp(tokens[0], "alias")==0){
        alias(tokens, aliases);
    }
    else if(strcmp(tokens[0],"hop")==0){
        char cwd[MAX];
        getcwd(cwd, MAX);
        if(hop(tokens, homedir, *ptrprevdir) == 0){
            if(strcmp(*ptrprevdir,"NULL")==0){
                *ptrprevdir = (char*)malloc(MAX*sizeof(char));
            }
            strcpy(*ptrprevdir, cwd);
        }
        //printf("prevdir is %s\n",*ptrprevdir);
    }else if(strcmp(tokens[0], "pwd")==0){
        pwd();
        printf("\n"); // goto nextline
    }else if(strcmp(tokens[0], "reveal")==0){
        reveal(tokens, homedir, *ptrprevdir);
    }else if(strcmp(tokens[0], "proclore")==0){
        proclore(tokens);
    }
    else if(strcmp(tokens[0], "log")==0){
        log_func(tokens, homedir, ptrprevdir, input, aliases);
    }
    else if(strcmp(tokens[0], "seek")==0){
        seek(tokens, homedir);
    }
    else{
        struct sigaction sa;
        sa.sa_handler = &handle_sigchld;
        sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;
        sigemptyset(&sa.sa_mask);
        if (sigaction(SIGCHLD, &sa, NULL) == -1) {
            perror("sigaction");
            exit(EXIT_FAILURE);
        }
        int proc_id = fork();
        if(proc_id==0){
            int ecod = execvp(tokens[0], tokens);
            fprintf(stderr, ""RED"INVALID COMMAND %s\n"RESET"",tokens[0]);
            exit(ecod);
        }else if (proc_id > 0) { // Parent process
            int status;
            waitpid(proc_id, &status, 0);
        }
        
        return 1;
    }
    

    return 0;
}

// log.c

/*generated by GPT https://chatgpt.com/share/35bfdeb0-151c-4111-bc8e-cfac26358a07  (2nd last prompt)
prompt: I literally just pasted the rest of my files and politely asked it to implement a history

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include "constants.h"
#include "log.h"
#include "input.h"
#include "alias.h"
#include "utils.h"


int log_func(char** tokens, char* homedir, char** ptrprevdir, char* input, AliasList* aliases){
    char* history_file = pre_process_path(HISTORY_FILE, homedir);
    if(tokens[1] == NULL){
        print_history(history_file);
    }
    else if(strcmp(tokens[1], "purge")==0){
        clear_history(history_file);
    }
    else if(strcmp(tokens[1], "execute")==0){
        int index = atoi(tokens[2]);
        execute_history_command(index, homedir, ptrprevdir, input, history_file, aliases);
    }
    return 0;

}

void execute_history_command(int index, char* homedir, char** ptrprevdir, char* input, char* history_file, AliasList* aliases){
    FILE *fptr = fopen(history_file, "r");
    if (!fptr) {
        perror("Failed to open history file");
        return;
    }

    char buffer[MAX];
    int count = 0;
    while (fgets(buffer, MAX, fptr)) {
        if (++count == index) {
            buffer[strcspn(buffer, "\n")] = 0; // Remove newline
            // Execute command
            char **args = tokenise_input(buffer);
            execute_command(args, homedir, ptrprevdir, input, aliases);
            free(args);
            break;
        }
    }
    fclose(fptr);
}

void update_history(char* command, char* history_file) {
    command[strlen(command)-1]=0;
    if (is_log_command(command)) return; // do not update history

    FILE *fptr = fopen(history_file, "r+");
    if (!fptr) {
        fptr = fopen(history_file, "w");
        if (!fptr) {
            perror("Failed to open history file");
            return;
        }
    }

    char history[MAX_HISTORY][MAX];
    int count = 0;
    while (fgets(history[count], MAX, fptr) && count < MAX_HISTORY) {
        history[count][strcspn(history[count], "\n")] = 0; // Remove newline
        count++;
    }
    fclose(fptr);

    // printf("last command:%s:\npresent command:%s:\nequality is %d\n",history[count - 1], command, strcmp(history[count - 1], command) == 0);
    if (count > 0 && strcmp(history[count - 1], command) == 0) {
        // Don't store duplicate command
        //printf("Do not duplicate\n");
        return;
    }

    fptr = fopen(history_file, "w");
    int start = (count >= MAX_HISTORY) ? 1 : 0;
    for (int i = start; i < count; i++) {
        fprintf(fptr, "%s\n", history[i]);
    }
    fprintf(fptr, "%s", command);
    fclose(fptr);
}

void print_history(char* history_file) {
    FILE *fptr = fopen(history_file, "r");
    if (!fptr) {
        perror("Failed to open history file");
        return;
    }

    char buffer[MAX];
    int count = 0;
    while (fgets(buffer, MAX, fptr)) {
        printf("%d %s", count + 1, buffer);
        count++;
    }
    printf("\n");
    fclose(fptr);
}

void clear_history(char* history_file) {
    FILE *fptr = fopen(history_file, "w");
    if (fptr) {
        fclose(fptr);
    }
}


int is_log_command(const char* command) {
    if(strcmp(command, "log")==0) return 1;
    return strstr(command, "log ") != NULL;
}


I will provide more files in a further prompt, hang on.