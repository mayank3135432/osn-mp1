//input.c


/*Modified code initially generated by GPT
https://chatgpt.com/share/35bfdeb0-151c-4111-bc8e-cfac26358a07 - first prompt
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include "constants.h"
#include "hop.h"
#include "pwd.h"
#include "reveal.h"
#include "proclore.h"
#include "log.h"
#include "seek.h"
#include "alias.h"


char *read_input(){
    char *input = malloc(MAX * sizeof(char));
    if(!input){
        fprintf(stderr, "allocation error\n");
        exit(EXIT_FAILURE);
    }

    if(fgets(input, MAX, stdin) == NULL){
        if(feof(stdin)){
            exit(EXIT_SUCCESS);  // EOF, exit shell
        }
        else{
            perror("read_input");
            exit(EXIT_FAILURE);
        }
    }

    return input;
}

char** tokenise_input(char* X){
    char* token;
    char** tokens = (char**)malloc(MAX*sizeof(char*));
    token=strtok(X, TOKEN_DELIMITERS);
    int count=0;
    while(token != NULL){
        tokens[count] = token;

        count++;
        //printf("%dth loop\n",count++);
        //printf("%s\n",token);
        token=strtok(NULL, TOKEN_DELIMITERS);
    }
    tokens[count] = NULL;
    return tokens;
}

void handle_sigchld() {
    // Wait for all dead child processes
    while (waitpid(-1, NULL, WNOHANG) > 0);
}

int execute_command(char** tokens, char* homedir, char** ptrprevdir, char* input, AliasList* aliases, int expand_alias_flag){
    if(tokens[0]==NULL) return 0;
    if(expand_alias_flag){
        for (int i = 0; i < aliases->alias_count; i++) { // check for aliases
            if (strcmp(aliases->element[i].alias, tokens[0]) == 0) {
                char** newtokens = use_alias(tokens, input, aliases, i);
                int errco = execute_command(newtokens, homedir, ptrprevdir, input, aliases, 0);
                return errco;
            }
        }
    }
    for(int i=0; tokens[i] != NULL; i++){
        if(strcmp(tokens[i], "&")==0){
            tokens[i]=NULL;
            struct sigaction sa;
            sa.sa_handler = &handle_sigchld;
            sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;
            sigemptyset(&sa.sa_mask);
            if (sigaction(SIGCHLD, &sa, NULL) == -1) {
                perror("sigaction");
                exit(EXIT_FAILURE);
            }
            int proc_id = fork();
            if(proc_id==0){
                int eid = execute_command(tokens, homedir, ptrprevdir, input, aliases, 1);
                exit(eid);
            }
            printf(""MAG"Process running in background with PID: "RESET"%d\n", proc_id);
            execute_command(tokens+i+1, homedir, ptrprevdir, input, aliases, 1);
            return 0;
        }
        if(strcmp(tokens[i], ";")==0){
            // replace first semicolon with NULL
            // and execute the tokens before it
            // and then recursively apply execute to the rest of the tokens
            tokens[i]=NULL; 
            execute_command(tokens, homedir, ptrprevdir, input, aliases, 1); 
            execute_command(tokens+i+1, homedir, ptrprevdir, input, aliases, 1);
            return 0;
        }
    }
    if(strcmp(tokens[0], "alias")==0){
        alias(tokens, aliases);
    }
    else if(strcmp(tokens[0],"hop")==0){
        char cwd[MAX];
        getcwd(cwd, MAX);
        if(hop(tokens, homedir, *ptrprevdir) == 0){
            if(strcmp(*ptrprevdir,"NULL")==0){
                *ptrprevdir = (char*)malloc(MAX*sizeof(char));
            }
            strcpy(*ptrprevdir, cwd);
        }
        //printf("prevdir is %s\n",*ptrprevdir);
    }else if(strcmp(tokens[0], "pwd")==0){
        pwd();
        printf("\n"); // goto nextline
    }else if(strcmp(tokens[0], "reveal")==0){
        reveal(tokens, homedir, *ptrprevdir);
    }else if(strcmp(tokens[0], "proclore")==0){
        proclore(tokens);
    }
    else if(strcmp(tokens[0], "log")==0){
        log_func(tokens, homedir, ptrprevdir, input, aliases);
    }
    else if(strcmp(tokens[0], "seek")==0){
        seek(tokens, homedir);
    }
    else{
        struct sigaction sa;
        sa.sa_handler = &handle_sigchld;
        sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;
        sigemptyset(&sa.sa_mask);
        if (sigaction(SIGCHLD, &sa, NULL) == -1) {
            perror("sigaction");
            exit(EXIT_FAILURE);
        }
        int proc_id = fork();
        if(proc_id==0){
            int ecod = execvp(tokens[0], tokens);
            fprintf(stderr, ""RED"INVALID COMMAND %s\n"RESET"",tokens[0]);
            exit(ecod);
        }else if (proc_id > 0) { // Parent process
            int status;
            waitpid(proc_id, &status, 0);
        }
        
        return 1;
    }
    

    return 0;
}

