/*
code generated by chatGPT https://chatgpt.com/c/41137d7e-a044-4581-960e-46ca8bb4409a
prompt : let us say I want to implement a command 'reveal' that lists content of present directory. How do I do that ?
further prompt : let's say i want to implement optional arguments of reveal such as -a to list dotfiles and -l to display file details too. How do I do that ? The current tokenize function does not support it

*/
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include "constants.h"
#include <time.h>

// Function to implement the 'reveal' command
int reveal(char **tokens, char* homedir, char* prevdir){
    DIR *d;
    struct dirent *dir;
    struct stat file_stat;
    char* cwd = NULL;
    int show_all = 0;
    int show_long = 0;
    int i = 1;

    // Parse options
    while (tokens[i] != NULL){
        if(strcmp(tokens[i],"-")==0){
            //printf("reveal : prevdir is %s\n",prevdir);
            cwd = prevdir;
        }
        else if(tokens[i][0] == '-'){
            if (strchr(tokens[i], 'a')) {
                show_all = 1; // Show dotfiles
            }
            if (strchr(tokens[i], 'l')) {
                show_long = 1; // Show long format
            }
        }
        else if(tokens[i][0] == '~'){            
            char* fullname = (char*)malloc((strlen(tokens[i])+strlen(homedir))*sizeof(char));
            strcpy(fullname, homedir);
            strcat(fullname, 1 + tokens[1]);
            
            cwd = fullname;
            //printf("homedir is %s : inputdir is %s\n",homedir,cwd);
        }
        else{
            cwd = tokens[i];
            //printf("%s\n",cwd);
        }
        i++;
    }

    if(cwd == NULL){
        // Get the current working directory
        cwd = (char*)malloc(MAX*sizeof(char));
        if (getcwd(cwd, MAX) == NULL) {
            fprintf(stderr, ""RED"could not getcwd"RESET"\n");
            return 1;
        }
    }

    // Open the current directory
    d = opendir(cwd);
    if (d == NULL) {
        fprintf(stderr, ""RED"could not opendir"RESET"\n");
        return 1;
    }

    // Read and print each entry in the directory
    while ((dir = readdir(d)) != NULL) {
        // Skip dotfiles if -a is not specified
        if (!show_all && dir->d_name[0] == '.') {
            continue;
        }

        // Print long format if -l is specified
        if (show_long) {
            if (stat(dir->d_name, &file_stat) == -1) {
                perror("stat");
                continue;
            }
            printf("%c%c%c%c%c%c%c%c%c%c %ld %s %s %ld %s\n",
                   (S_ISDIR(file_stat.st_mode)) ? 'd' : '-',
                   (file_stat.st_mode & S_IRUSR) ? 'r' : '-',
                   (file_stat.st_mode & S_IWUSR) ? 'w' : '-',
                   (file_stat.st_mode & S_IXUSR) ? 'x' : '-',
                   (file_stat.st_mode & S_IRGRP) ? 'r' : '-',
                   (file_stat.st_mode & S_IWGRP) ? 'w' : '-',
                   (file_stat.st_mode & S_IXGRP) ? 'x' : '-',
                   (file_stat.st_mode & S_IROTH) ? 'r' : '-',
                   (file_stat.st_mode & S_IWOTH) ? 'w' : '-',
                   (file_stat.st_mode & S_IXOTH) ? 'x' : '-',
                   file_stat.st_nlink,
                   getenv("USER"), // Owner (you could improve this with getpwuid)
                   getenv("USER"), // Group (you could improve this with getgrgid)
                   file_stat.st_size,
                   ctime(&file_stat.st_mtime)
            );
        } else {
            printf("%s\n", dir->d_name);
        }
    }

    // Close the directory
    closedir(d);
    return 1;
}

