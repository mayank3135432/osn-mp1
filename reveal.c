// reveal.c

/*
code generated by chatGPT https://chatgpt.com/c/41137d7e-a044-4581-960e-46ca8bb4409a
prompt : let us say I want to implement a command 'reveal' that lists content of present directory. How do I do that ?
further prompt : let's say i want to implement optional arguments of reveal such as -a to list dotfiles and -l to display file details too. How do I do that ? The current tokenize function does not support it

*/
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include "constants.h"
#include <time.h>
#include <grp.h>
#include <pwd.h>

#include "utils.h"
char* append_path_to_dirname(char* cwd, struct dirent *dir){
    char* path = (char*)malloc(MAX*sizeof(char));
    snprintf(path, MAX, "%s/%s", cwd, dir->d_name);
    return path;
}
// Function to implement the 'reveal' command
int reveal(char **tokens, char* homedir, char* prevdir){
    DIR *d;
    struct dirent *dir;
    struct stat file_stat;
    struct passwd *pw;
    struct group *gr;
    char* cwd = NULL;
    int show_all = 0;
    int show_long = 0;
    int i = 1;

    // Parse options
    while (tokens[i] != NULL){
        tokens[i] = pre_process_path(tokens[i], homedir);
        if(strcmp(tokens[i],"-")==0){
            //printf("reveal : prevdir is %s\n",prevdir);
            cwd = prevdir;
        }
        else if(tokens[i][0] == '-'){
            if (strchr(tokens[i], 'a')) {
                show_all = 1; // Show dotfiles
            }
            if (strchr(tokens[i], 'l')) {
                show_long = 1; // Show long format
            }
        }
        else{
            cwd = tokens[i];
            //printf("%s\n",cwd);
        }
        i++;
    }

    if(cwd == NULL){
        // Get the current working directory
        cwd = (char*)malloc(MAX*sizeof(char));
        if (getcwd(cwd, MAX) == NULL) {
            fprintf(stderr, ""RED"could not getcwd"RESET"\n");
            return 1;
        }
    }

    // Open the current directory
    //printf("directory to b opened is %s\n",cwd);
    d = opendir(cwd);
    if (d == NULL) {
        fprintf(stderr, ""RED"could not opendir"RESET"\n");
        return 1;
    }

    
/*     int fx = fork();
    if(fx>0) return 0;
    chdir(cwd);
 */
    /* 
    int n = scandir(cwd, &namelist, NULL, alphasort);
    if (n == -1) {
        perror("scandir");
        return 1;
    } 
    */
    // Read and print each entry in the directory
    while ((dir = readdir(d)) != NULL) {
        
        // Skip dotfiles if -a is not specified
        if (!show_all && dir->d_name[0] == '.') {
            continue;
        }

        // Print long format if -l is specified
        if (show_long) {
            //printf("before segma cwd/dir->d_name is %s/%s\n",cwd,dir->d_name);
            // edge case when dir->d_name is ..
            // causes segma

            char* path = (strcmp(dir->d_name, "..") != 0)? append_path_to_dirname(cwd, dir):".."; // handle edge case
            //printf("before segma path is %s\n",path); --debug line
            if (stat(path, &file_stat) == -1) {
                fprintf(stderr, ""RED"could not stat"RESET"\n");
                continue;
            }

            pw = getpwuid(file_stat.st_uid);
            gr = getgrgid(file_stat.st_gid);
            //printf("is reach ?\n"); --dubug line
            char *time_str = ctime(&file_stat.st_mtime);
            time_str[strlen(time_str) - 1] = '\0';
            printf("%c%c%c%c%c%c%c%c%c%c %ld %s %s %ld %s ",
                   (S_ISDIR(file_stat.st_mode)) ? 'd' : '-',
                   (file_stat.st_mode & S_IRUSR) ? 'r' : '-',
                   (file_stat.st_mode & S_IWUSR) ? 'w' : '-',
                   (file_stat.st_mode & S_IXUSR) ? 'x' : '-',
                   (file_stat.st_mode & S_IRGRP) ? 'r' : '-',
                   (file_stat.st_mode & S_IWGRP) ? 'w' : '-',
                   (file_stat.st_mode & S_IXGRP) ? 'x' : '-',
                   (file_stat.st_mode & S_IROTH) ? 'r' : '-',
                   (file_stat.st_mode & S_IWOTH) ? 'w' : '-',
                   (file_stat.st_mode & S_IXOTH) ? 'x' : '-',
                   file_stat.st_nlink,
                   pw->pw_name,
                   gr==NULL?""RED"NULL"RESET"":gr->gr_name, // handle problamatic case
                   // give NULL if group not found (eg for 1000)
                   file_stat.st_size,
                   time_str
            );
            if(S_ISDIR(file_stat.st_mode)){
                printf(""BLU"%s"RESET"\n", dir->d_name);
            }
            else if(file_stat.st_mode & S_IXUSR){
                printf(""GRN"%s"RESET"\n", dir->d_name);
            }
            else{
                printf("%s\n", dir->d_name);
            }
            
        } else {
            //char* path = append_path_to_dirname(cwd, dir);
            char* path = (strcmp(dir->d_name, "..") != 0)? append_path_to_dirname(cwd, dir):".."; // handle edge case
            if (stat(path, &file_stat) == -1) {
                fprintf(stderr, ""RED"reveal : could not stat"RESET"\n");
                continue;
            }
            if(S_ISDIR(file_stat.st_mode)){
                printf(""BLU"%s"RESET"\n", dir->d_name);
            }
            else if(file_stat.st_mode & S_IXUSR){
                printf(""GRN"%s"RESET"\n", dir->d_name);
            }
            else{
                printf("%s\n", dir->d_name);
            }
        }
    }

    // Close the directory
    closedir(d);
    return 0;
}

